<!DOCTYPE html><html lang="ru"><head><title>JavaScript Гарден</title><meta charset="utf-8"><meta name="description" content="Руководство по хитростям и трюкам JavaScript."><meta name="viewport" content="width=device-width, initial-scale=1"><link rel="shortcut icon" href="/JavaScript-Garden/favicon.ico?v=2"><link rel="stylesheet" href="../style/garden.css" media="all"><link rel="stylesheet" href="../style/print.css" media="print"><!--[if lt IE 9]>
<script src="javascript/html5.js"></script>
<![endif]--></head><body><!-- Navigation--><nav id="nav_main"><div><ul><li><a href="/JavaScript-Garden/by" title="JavaScript Garden">by</a></li><li><a href="/JavaScript-Garden/" title="JavaScript Garden">en</a></li><li><a href="/JavaScript-Garden/es" title="Jardín de JavaScript">es</a></li><li><a href="/JavaScript-Garden/fi" title="JavaScript-puutarha">fi</a></li><li><a href="/JavaScript-Garden/fr" title="Le Jardin de JavaScript">fr</a></li><li><a href="/JavaScript-Garden/hu" title="JavaScript Garden">hu</a></li><li><a href="/JavaScript-Garden/it" title="JavaScript Garden">it</a></li><li><a href="/JavaScript-Garden/ja" title="JavaScript Garden">ja</a></li><li><a href="/JavaScript-Garden/ko" title="JavaScript Garden">ko</a></li><li><a href="/JavaScript-Garden/pl" title="JavaScript Garden">pl</a></li><li><a href="/JavaScript-Garden/ptbr" title="JavaScript Garden">ptbr</a></li><li class="active"><a href="/JavaScript-Garden/ru" title="JavaScript Гарден">ru</a></li><li><a href="/JavaScript-Garden/tr" title="JavaScript Garden">tr</a></li><li><a href="/JavaScript-Garden/zh" title="JavaScript 秘密花园">zh</a></li><li><a href="/JavaScript-Garden/zhtw" title="JavaScript Garden">zhtw</a></li></ul><a id="top" href="#intro" title="Back to top">#top</a><a id="hide_menu" class="tablet">Hide Menu</a></div><ul><li class="nav_intro"><h1><a href="#intro">Вступление</a></h1><ul></ul></li><li class="nav_object"><h1><a href="#object">Объекты</a></h1><ul><li><a href="#object.general">Объекты и их свойства</a></li><li><a href="#object.prototype">Великий Прототип</a></li><li><a href="#object.hasownproperty">Функция <code>hasOwnProperty</code></a></li><li><a href="#object.forinloop">Цикл <code>for in</code></a></li></ul></li><li class="nav_function"><h1><a href="#function">Функции</a></h1><ul><li><a href="#function.general">Про объявление функций и о выражениях с ними</a></li><li><a href="#function.this">Как работает <code>this</code></a></li><li><a href="#function.closures">Замыкания и ссылки</a></li><li><a href="#function.arguments">Объект <code>arguments</code></a></li><li><a href="#function.constructors">Конструктор</a></li><li><a href="#function.scopes">Области видимости и пространства имён</a></li></ul></li><li class="nav_array"><h1><a href="#array">Массивы</a></h1><ul><li><a href="#array.general">Перебор массивов и свойств объектов</a></li><li><a href="#array.constructor">Конструктор <code>Array</code></a></li></ul></li><li class="nav_types"><h1><a href="#types">Типы</a></h1><ul><li><a href="#types.equality">Равенство и сравнения</a></li><li><a href="#types.typeof">Оператор <code>typeof</code></a></li><li><a href="#types.instanceof">Оператор <code>instanceof</code></a></li><li><a href="#types.casting">Приведение типов</a></li></ul></li><li class="nav_core"><h1><a href="#core">Ядро</a></h1><ul><li><a href="#core.eval">Почему нельзя использовать <code>eval</code></a></li><li><a href="#core.undefined"><code>undefined</code> и <code>null</code></a></li><li><a href="#core.semicolon">Автоматическая вставка точек с запятой</a></li><li><a href="#core.delete">Оператор <code>delete</code></a></li></ul></li><li class="nav_other"><h1><a href="#other">Другое</a></h1><ul><li><a href="#other.timeouts"><code>setTimeout</code> и <code>setInterval</code></a></li></ul></li><li class="nav_appendix"><h1><a href="#appendix">Пояснения</a></h1><ul><li><a href="#appendix.fromtranslators">От переводчиков</a></li></ul></li></ul></nav><!-- Mobile navigation--><nav id="nav_mobile"><a id="nav_prev_section" href="#">prev section<span class="nav_section_name">section name</span></a><a id="nav_next_section" href="#">next section<span class="nav_section_name">section name</span></a><a id="show_menu">show menu</a></nav><!-- Sections--><section id="intro"><!-- Introduction--><header id="intro.intro"><h1>Вступление</h1></header><!-- Articles--><article id="intro.authors"><h2>Авторы</h2><div><p>Это руководство является результатом работы двух заядлых пользователей <a href="http://stackoverflow.com/">Stack Overflow</a>: <a href="http://stackoverflow.com/users/170224/ivo-wetzel">Иво Ветцель /Ivo Wetzel/</a> (автора текста) и <a href="http://stackoverflow.com/users/313758/yi-jiang">Чжан И Цзян /Zhang Yi Jiang/</a> (дизайнера).</p>
</div></article><article id="intro.contributors"><h2>Участники</h2><div><ul>
<li><a href="https://github.com/BonsaiDen/JavaScript-Garden/graphs/contributors">Участники</a></li>
</ul>
</div></article><article id="intro.hosting"><h2>Хостинг</h2><div><p>JavaScript Garden хостится на <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>, однако <a href="http://cramerdev.com/">Cramer Development</a> поддерживают наше зеркало на <a href="http://javascriptgarden.info/">JavaScriptGarden.info</a>.</p>
</div></article><article id="intro.translators"><h2>Переводчики</h2><div><ul>
<li><a href="http://shamansir.github.com/">&#39;shaman.sir&#39;</a></li>
<li><a href="http://anton.shevchuk.name/">Антон Шевчук</a></li>
<li><a href="http://nixsolutions.com/">Максим Лозовой</a></li>
<li><a href="http://nixsolutions.com/">Елена Пашкова</a></li>
<li><a href="http://habrahabr.ru/users/binariti/">binariti</a> очень помог со стилистикой текста</li>
</ul>
</div></article><article id="intro.license"><h2>Лицензия</h2><div><p>JavaScript Гарден распространяется под <a href="https://github.com/BonsaiDen/JavaScript-Garden/blob/next/LICENSE">лицензией MIT</a> и располагается на <a href="https://github.com/BonsaiDen/JavaScript-Garden">GitHub</a>. Если вы найдёте ошибку или опечатку, пожалуйста <a href="https://github.com/BonsaiDen/JavaScript-Garden/issues">сообщите нам о ней</a> или запросите права на загрузку в репозиторий. Кроме того, вы можете найти нас в <a href="http://chat.stackoverflow.com/rooms/17/javascript">комнате JavaScript</a> среди чатов Stack Overflow.</p>
</div></article></section><section id="object"><!-- Introduction--><header id="object.intro"><h1>Объекты</h1></header><!-- Articles--><article id="object.general"><h2>Объекты и их свойства</h2><div><p>В JavaScript все значения ведут себя как объекты, лишь за двумя исключениями — <a href="#core.undefined"><code>null</code></a> и <a href="#core.undefined"><code>undefined</code></a>.</p>
<pre><code>false.toString(); // &#39;false&#39;
[1, 2, 3].toString(); // &#39;1,2,3&#39;

function Foo(){}
Foo.bar = 1;
Foo.bar; // 1</code></pre>
<p>Среди программистов на JavaScript распростанено заблуждение, что числовые литералы нельзя использовать в роли объектов — оно является неверным и зародилось по причине известного упущения в парсере JavaScript, благодаря которому применение <em>точечной нотации</em> к числу воспринимается им как литерал числа с плавающей точкой.</p>
<pre><code>2.toString(); // вызывает SyntaxError</code></pre>
<p>Есть несколько способов обойти этот недостаток, и любой из них подойдёт, когда вам действительно нужно добиться поведения объекта от числового значения:</p>
<pre><code>2..toString(); // вторая точка распознаётся корректно
2 .toString(); // обратите внимание на пробел перед точкой
(2).toString(); // двойка вычисляется заранее</code></pre>
<h3 id="-">Объекты как хранилища данных</h3>
<p>Объекты в JavaScript могут использоваться и как <a href="http://ru.wikipedia.org/wiki/%D0%A5%D0%B5%D1%88-%D1%82%D0%B0%D0%B1%D0%BB%D0%B8%D1%86%D0%B0"><em>хеш-таблицы</em></a>: большей частью они состоят из именованных свойств (ключей), привязанных к соответствующим значениям.</p>
<p>Используя объектный литерал — нотацию <code>{}</code> — можно создать простой объект. Новый объект <a href="#object.prototype">наследуется</a> от <code>Object.prototype</code> и не имеет <a href="#object.hasownproperty">собственных свойств</a>.</p>
<pre><code>var foo = {}; // новый пустой объект

// новый объект со свойством &#39;test&#39;, имеющим значение 12
var bar = {test: 12};</code></pre>
<h3 id="-">Доступ к свойствам</h3>
<p>Получить доступ к свойствам объекта можно двумя способами: используя либо точечную нотацию, либо запись квадратными скобками.</p>
<pre><code>var foo = {name: &#39;kitten&#39;}
foo.name; // kitten
foo[&#39;name&#39;]; // kitten

var get = &#39;name&#39;;
foo[get]; // kitten

foo.1234; // SyntaxError
foo[&#39;1234&#39;]; // работает</code></pre>
<p>Обе нотации идентичны по принципу работы; разница между ними лишь в том, что использование квадратных скобок позволяет устанавливать свойства динамически и использовать такие имена свойств, какие в других случаях могли бы привести к синтаксической ошибке.</p>
<h3 id="-">Удаление свойств</h3>
<p>Единственный способ полностью удалить свойство у объекта — использовать оператор <code>delete</code>; устанавливая свойство в <code>undefined</code> или <code>null</code>, вы только заменяете связанное с ним <em>значение</em>, но не удаляете <em>ключ</em>.</p>
<aside>
<p><strong>Замечание</strong> от перев.: Если ссылок на значение больше нет, то сборщиком мусора удаляется и само значение, но ключ объекта при этом всё также указывает на новое значение.</p>
</aside>
<pre><code>var obj = {
    bar: 1,
    foo: 2,
    baz: 3
};
obj.bar = undefined;
obj.foo = null;
delete obj.baz;

for(var i in obj) {
    if (obj.hasOwnProperty(i)) {
        console.log(i, &#39;&#39; + obj[i]);
    }
}</code></pre>
<p>Приведённый код выведет две строки — <code>bar undefined</code> и <code>foo null</code>: на самом деле удалено было только свойство <code>baz</code> и поэтому лишь оно будет отсутствовать в выводе.</p>
<h3 id="-">Запись ключей</h3>
<pre><code>var test = {
    &#39;case&#39;: &#39;Я — ключевое слово, поэтому меня надо записывать строкой&#39;,
    delete: &#39;Я тоже ключевое слово, и меня&#39; // не является ошибкой, бросает SyntaxError только в версиях ECMAScript ниже 5ой версии
};</code></pre>
<p>Ключи для свойств объектов могут записываться как посимвольно без кавычек, так и в виде закавыченных строк. В связи с другим упущением в парсере JavaScript, вышеприведённый код породит <code>SyntaxError</code> во всех версиях ранее ECMAScript 5.</p>
<p>Источником ошибки является факт, что <code>delete</code> — это <em>ключевое слово</em> и поэтому его <em>необходимо</em> записывать как <em>строчный литерал</em>, хотя бы ради уверенности, что оно будет корректно опознано более старыми движками JavaScript.</p>
<p><em>От перев.:</em> Дополнительный пример в пользу строковой нотации, это относится к <a href="http://ru.wikipedia.org/wiki/JSON">JSON</a>:</p>
<pre><code>// валидный JavaScript и валидный JSON
{
    &quot;foo&quot;: &quot;oof&quot;,
    &quot;bar&quot;: &quot;rab&quot;
}

// валидный JavaScript и НЕвалидный JSON
{
    foo: &quot;oof&quot;,
    bar: &quot;rab&quot;
}</code></pre>
</div></article><article id="object.prototype"><h2>Великий Прототип</h2><div><p>В JavaScript отсутствует классическая модель наследования — вместо неё используется <a href="http://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D1%82%D0%BE%D1%82%D0%B8%D0%BF%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5"><em>прототипная модель</em></a>.</p>
<p>Хотя её и причисляют к недостаткам JavaScript, на самом деле прототипная модель наследования оказывается <em>мощнее</em> классической. К примеру, поверх неё можно предельно легко реализовать классическое наследование, а попытки совершить обратное вынудят вас попотеть.</p>
<p>Из-за того, что JavaScript — практически единственный широко используемый язык с прототипным наследованием, придётся потратить некоторое время на осознание различий между этими двумя моделями.</p>
<p>Первое важное отличие заключается в том, что наследование в JavaScript выполняется с использованием так называемых  <em>цепочек прототипов</em>.</p>
<aside>
<p><strong>Замечание:</strong> При использовании конструкции <code>Bar.prototype = Foo.prototype</code> оба объекта будут делить друг с другом <strong>один и тот же</strong> прототип. Так что изменение прототипа одного из объектов повлечёт за собой изменение прототипа другого и наоборот — вряд ли это то, чего вы ожидали.</p>
<p><strong>Замечание:</strong> Для объявления наследования вместо <code>Bar.prototype = Object.create(Foo.prototype)</code> можно воспользоваться конструкций <code>Bar.prototype = new Foo()</code>, но у нее есть пару недостатков: 1) как правило требуется унаследовать только методы и свойства прототипа, а не создавать для этого новый объект; 2) создание объекта может требовать обязательные аргументы.</p>
<p><strong>Примечание:</strong> Метод <code>Object.create</code> отсутствует в IE8 и ниже, но его легко реализовать созданием своей такой функции или же можно подключить библиотеку для поддержки старых IE <a href="https://github.com/es-shims/es5-shim"><em>es5-shim</em></a></p>
</aside>
<pre><code>function Foo() {
    this.value = 42;
}
Foo.prototype.method = function() {}

function Bar() {}

// Зададим наследование от Foo
Bar.prototype = Object.create(Foo.prototype);
Bar.prototype.foo = &#39;Hello World&#39;;

// Убедимся, что Bar является настоящим конструктором
Bar.prototype.constructor = Bar;

var test = new Bar() // создадим новый экземпляр bar

// Цепочка прототипов, которая получится в результате
test [instance of Bar]
    Bar.prototype [instance of Foo]
        { foo: &#39;Hello World&#39;, value: 42 }
        Foo.prototype
            { method: ... }
            Object.prototype
                { toString: ... /* и т.д. */ }</code></pre>
<p>В приведённом коде объект <code>test</code> будет наследовать оба прототипа: <code>Bar.prototype</code> и <code>Foo.prototype</code>; следовательно, у него будет доступ к функции <code>method</code>, которую мы определили в прототипе <code>Foo</code>. Также, у него будет доступ к свойству <code>value</code> <strong>одного уникального</strong> экземпляра <code>Foo</code>, который является его прототипом. Важно заметить, что код <code>new Bar()</code> при вызове <strong>не создаёт</strong> новый экземпляр <code>Foo</code>, а повторно вызываеи функцию, которая была назначена его (<code>Bar</code>) прототипом: таким образом, все новые экземпляры <code>Bar</code> будут иметь <strong>одно и то же</strong> свойство <code>value</code> (<em>прим. перев.</em> — то есть все ссылки по имени <code>value</code>, во всех экземплярах <code>Bar</code>, будут указывать на одно и то же место в памяти).</p>
<aside>
<p><strong>Замечание:</strong> Никогда <strong>не используйте</strong> конструкцию <code>Bar.prototype = Foo</code>, поскольку ссылка будет указывать не на прототип <code>Foo</code>, а на объект-функцию <code>Foo</code>. Из-за этого цепочка прототипов будет проходить через <code>Function.prototype</code>, а не через <code>Foo.prototype</code>, в результате чего функция <code>method</code> вообще не будет содержаться в цепочке прототипов.</p>
</aside>
<h3 id="-">Поиск свойств</h3>
<p>При обращении к какому-либо свойству объекта, движок JavaScript проходит <strong>вверх</strong> по цепочке прототипов этого объекта, пока не найдет свойство c запрашиваемым именем.</p>
<p>Если он достигнет верхушки этой цепочки (а именно <code>Object.prototype</code>), и при этом так и не найдёт указанное свойство, вместо него вернётся значение <a href="#core.undefined">undefined</a>.</p>
<h3 id="-prototype-">Свойство <code>prototype</code></h3>
<p>Тот факт, что свойство <code>prototype</code> используется языком для построения цепочек прототипов, даёт нам возможность присвоить <strong>любое</strong> значение этому свойству. Впрочем, обычные примитивы, если назначать их в качестве прототипов, будут просто-напросто игнорироваться.</p>
<pre><code>function Foo() {}
Foo.prototype = 1; // никакого эффекта
Foo.prototype = {
    &quot;foo&quot;:&quot;bar&quot;
}; // это сработает</code></pre>
<p>Но присвоение объектов, как в примерах здесь и выше, работает, и позволяет вам создавать цепочки прототипов динамически.</p>
<h3 id="-">Производительность</h3>
<p>Поиск свойств, располагающихся относительно высоко по цепочке прототипов, может негативно сказаться на производительности, особенно в критичных к ней местах кода. Если же мы попытаемся найти несуществующее свойство, поиск будет осуществлён по всей цепочке вообще, до самого глубокого конца — со всеми вытекающими последствиями.</p>
<p>Вдобавок, при <a href="#object.forinloop">циклическом переборе</a> свойств объекта, будет обработано <strong>каждое</strong> свойство, существующее в цепочке прототипов.</p>
<h3 id="-">Расширение встроенных прототипов</h3>
<p>Часто встречается неверное применение прототипов — расширение прототипа <code>Object.prototype</code> или прототипов одного из встроенных объектов JavaScript.</p>
<p>Подобная практика нарушает принцип <em>инкапсуляции</em> и имеет соответствующее название — <a href="http://en.wikipedia.org/wiki/Monkey_patch">monkey patching</a>. К сожалению, в основу многих широко распространенных фреймворков, например Prototype, положен принцип изменения базовых прототипов. На самом деле — до сих пор не известно разумных причин примешивать во встроенные типы <em>нестандартную функциональность</em>.</p>
<p><strong>Единственным</strong> оправданием для расширения встроенных прототипов может быть только воссоздание возможностей более новых движков JavaScript, например функции <a href="https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/Array/forEach"><code>Array.forEach</code></a>, которая появилась в версии 1.6.</p>
<h3 id="-">Заключение</h3>
<p>Перед тем, как вы приступите к разработке сложных приложений на JavaScript с использованием прототипов, вы <strong>должны</strong> полностью осознать как работают прототипные цепочки, и как организовывать наследование на их основе. Также, помните о зависимости между длиной цепочек прототипов и производительностью — разрывайте их при необходимости. Кроме того — <strong>никогда</strong> не расширяйте прототипы встроенных объектов, если вы не делаете это для совместимости с новыми возможностями Javascript.</p>
</div></article><article id="object.hasownproperty"><h2>Функция <code>hasOwnProperty</code></h2><div><p>Если вам необходимо проверить, определено ли свойство у <em>самого объекта</em>, а <strong>не</strong> где-то в его <a href="#object.prototype">цепочке прототипов</a>, вы можете использовать метод <code>hasOwnProperty</code>, который все объекты наследуют от <code>Object.prototype</code>.</p>
<aside>
<p><strong>Примечание:</strong> Для проверки существования свойства <strong>недостаточно</strong> проверять, эквивалентно ли оно <code>undefined</code>. Свойство может вполне себе существовать, но при этом ему может быть присвоено значение <code>undefined</code>.</p>
</aside>
<p><code>hasOwnProperty</code> — единственная функция в JavaScript, которая помогает получать свойства объекта <strong>без обращения</strong> к цепочке его прототипов.</p>
<pre><code>// Подпортим Object.prototype
Object.prototype.bar = 1;
var foo = {goo: undefined};

foo.bar; // 1
&#39;bar&#39; in foo; // true

foo.hasOwnProperty(&#39;bar&#39;); // false
foo.hasOwnProperty(&#39;goo&#39;); // true</code></pre>
<p>Только используя <code>hasOwnProperty</code> можно гарантировать правильный результат при переборе свойств объекта в циклах. И <strong>нет</strong> иного способа для отделения свойств, которые определены в <em>самом</em> объекте, а не где-либо в цепочке его прототипов.</p>
<h3 id="-hasownproperty-"><code>hasOwnProperty</code> как свойство</h3>
<p>JavaScript <strong>не</strong> резервирует свойство с именем <code>hasOwnProperty</code>. Так что, если есть потенциальная возможность, что объект может содержать свойство с таким именем — чтобы получить гарантированно ожидаемый результат, требуется использовать <em>внешний</em> вариант функции <code>hasOwnProperty</code>.</p>
<pre><code>var foo = {
    hasOwnProperty: function() {
        return false;
    },
    bar: &#39;Да прилетят драконы&#39;
};

foo.hasOwnProperty(&#39;bar&#39;); // всегда возвращает false

// Используем метод hasOwnProperty пустого объекта
// и передаём foo в качестве this
({}).hasOwnProperty.call(foo, &#39;bar&#39;); // true

// Для этих целей также можно использовать функцию hasOwnProperty из прототипа Object
Object.prototype.hasOwnProperty.call(foo, &#39;bar&#39;); // true</code></pre>
<p><em>От перев.:</em> Обратите внимание, что последний способ в примере не создаёт новых объектов</p>
<h3 id="-">Заключение</h3>
<p><strong>Единственным</strong> надёжным способом проверить существование свойства у объекта является использование метода <code>hasOwnProperty</code>. Рекомендуется использовать этот метод в <strong>любом</strong> <a href="#object.forinloop">цикле <code>for in</code></a> вашего проекта, дабы избежать потенциальных ошибок с неверным заимствованием свойств из <a href="#object.prototype">прототипов</a> встроенных объектов. Кроме этого, вы можете использовать конструкцию <code>{}.hasOwnProperty.call(...)</code> на случай, если кто-то вздумает расширить <a href="#object.prototype">прототипы</a> встроенных объектов.</p>
</div></article><article id="object.forinloop"><h2>Цикл <code>for in</code></h2><div><p>Как и оператор <code>in</code>, цикл <code>for in</code> проходит по всей цепочке прототипов, обходя свойства объекта.</p>
<aside>
<p><strong>Примечание:</strong> Цикл <code>for in</code> <strong>не</strong> обходит те свойства объекта, у которых внутренний атрибут <code>enumerable</code> установлен в <code>false</code>; как пример - свойство <code>length</code> у массивов.</p>
</aside>
<pre><code>// Подпортим Object.prototype
Object.prototype.bar = 1;

var foo = {moo: 2};
for(var i in foo) {
    console.log(i); // печатает и bar и moo
}</code></pre>
<p>Так как изменить поведение цикла <code>for in</code> как такового не представляется возможным, то для фильтрации нежелательных свойств объекта внутри этого цикла используется метод <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> из <code>Object.prototype</code>.</p>
<aside>
<p><strong>Примечание:</strong>  Цикл <code>for in</code> всегда обходит всю цепочку прототипов полностью: таким образом, чем больше прототипов (слоёв наследования) в цепочке, тем медленнее работает цикл.</p>
</aside>
<h3 id="-hasownproperty-">Использование <code>hasOwnProperty</code> в качестве фильтра</h3>
<pre><code>// всё то же foo из примера выше
for(var i in foo) {
    if (foo.hasOwnProperty(i)) {
        console.log(i);
    }
}</code></pre>
<p>Это единственно правильная версия выполнения цикла обхода ключей объекта. За счёт использования <code>hasOwnProperty</code> будет выведено одно <strong>только</strong> свойство <code>moo</code>. Если же вы уберёте проверку <code>hasOwnProperty</code>, код станет нестабилен и, если кто-то всё же позволил себе изменить прототипы встроенных типов, такие как <code>Object.prototype</code>, вам грозят непредвиденные сюрпризы.</p>
<p>Один из самых популярных фреймворков <a href="http://www.prototypejs.org/">Prototype</a> использует упомянутое расширение <code>Object.prototype</code> — и если вы его подключаете — ни в коем случае не забывайте использовать <code>hasOwnProperty</code> внутри всех циклов <code>for in</code> — иначе у вас гарантированно возникнут проблемы.</p>
<h3 id="-">Рекомендации</h3>
<p>Рекомендация одна — <strong>всегда</strong> используйте <code>hasOwnProperty</code>. Пишите код, который будет в наименьшей мере зависеть от окружения, в котором он будет запущен — не стоит гадать, расширял кто-то прототипы или нет и используется ли в нём та или иная библиотека.</p>
</div></article></section><section id="function"><!-- Introduction--><header id="function.intro"><h1>Функции</h1></header><!-- Articles--><article id="function.general"><h2>Про объявление функций и о выражениях с ними</h2><div><p>Функции в JavaScript являются объектами. Следовательно, их можно передавать и присваивать точно так же, как и любой другой объект. Популярное использование этого замечательного свойства — передача <em>анонимной функции</em> в качестве функции обратного вызова в некую другую функцию — к примеру, при описании асинхронных вызовов.</p>
<h3 id="-function-">Объявление <code>function</code></h3>
<pre><code>// всё просто и привычно
function foo() {}</code></pre>
<p>В следующем примере, ещё перед запуском всего скрипта, для описанной функции <a href="#function.scopes">резервируется</a> переменная; за счёт этого она становится доступна <em>в любом месте</em> кода, вне зависимости от того, где она <em>определена</em> — даже если она вызывается заранее, перед её фактическим объявлением в коде (и сколь угодно задолго до такого определения).</p>
<pre><code>foo(); // сработает, т.к. функция будет создана при компиляции, до выполнения кода
function foo() {}</code></pre>
<h3 id="-function-"><code>function</code> как выражение</h3>
<pre><code>var foo = function() {};</code></pre>
<p>В конце примера ниже переменной <code>foo</code> присваивается безымянная <em>анонимная</em> функция.</p>
<pre><code>foo; // &#39;undefined&#39;
foo(); // вызовет TypeError
var foo = function() {};</code></pre>
<p>Поскольку выражение с применением <code>var</code> <em>резервирует</em> имя переменной <code>foo</code> ещё до запуска кода, <code>foo</code> уже имеет некое значение во время его исполнения (ошибка «<code>foo</code> is not defined» отсутствует).</p>
<p>Но поскольку <em>сами присвоения</em> исполняются непосредственно во время работы кода, до выполнения строки с определением функции <code>foo</code> будет иметь значение <a href="#core.undefined"><code>undefined</code></a>.</p>
<h3 id="-">Выражения с именованными функциями</h3>
<p>Существует еще один нюанс, касающийся присваиваний именованных функций:</p>
<pre><code>var foo = function bar() {
    bar(); // работает
}
bar(); // получим ReferenceError</code></pre>
<p>Здесь фукнция <code>bar</code> не доступна во внешней области видимости, так как она используется только для присвоения переменной <code>foo</code>; однако, внутри <code>bar</code> она неожиданно оказывается доступна. Такое поведение связано с особенностью работы JavaScript с <a href="#function.scopes">разыменованием</a> - имя функции <em>всегда</em> доступно в локальной области видимости самой функции.</p>
</div></article><article id="function.this"><h2>Как работает <code>this</code></h2><div><p>В JavaScript зона ответственности специальной переменной <code>this</code> концептуально отличается от поведения <code>this</code> в других языках программирования. Различают ровно <strong>пять</strong> сущностей, к которым в этом языке может быть привязана переменная <code>this</code>.</p>
<h3 id="1-">1. Глобальная область видимости</h3>
<pre><code>this;</code></pre>
<p>Когда мы используем <code>this</code> в глобальной области видимости, она просто ссылается на <em>глобальный</em> объект.</p>
<h3 id="2-">2. Вызов функции</h3>
<pre><code>foo();</code></pre>
<p>Внутри функции <code>this</code> ссылается на <em>глобальный</em> объект.</p>
<aside>
<p><strong>Замечание касательно ES5:</strong> В strict-режиме <strong>отсутствует</strong> понятие глобальной видимости, поэтому <code>this</code> в этом случае будет иметь значение <code>undefined</code>.</p>
</aside>
<h3 id="3-">3. Вызов метода</h3>
<pre><code>test.foo();</code></pre>
<p>Внутри метода <code>this</code> ссылается на <code>test</code>.</p>
<h3 id="4-">4. Вызов конструктора</h3>
<pre><code>new foo();</code></pre>
<p>Если перед вызовом функции присутствует ключевое слово <code>new</code>, то данная функция будет действовать как <a href="#function.constructors">конструктор</a>. Внутри такой функции <code>this</code> будет указывать на <em>новый созданный</em> <code>Object</code>.</p>
<h3 id="5-this-">5. Переопределение <code>this</code></h3>
<pre><code>function foo(a, b, c) {}

var bar = {};
foo.apply(bar, [1, 2, 3]); // внутри foo массив развернётся в аргументы
foo.call(bar, 1, 2, 3); // аналогично: a = 1, b = 2, c = 3</code></pre>
<p>Когда мы используем методы <code>call</code> или <code>apply</code> из <code>Function.prototype</code>, то внутри вызываемой функции <code>this</code> <strong>явным образом</strong> будет присвоено значение первого передаваемого параметра.</p>
<p>Исходя из этого, в предыдущем примере (строка с <code>apply</code>), правило №3 <em>«вызов метода»</em> <strong>не</strong> применяется, и <code>this</code> внутри <code>foo</code> будет присвоено <code>bar</code>.</p>
<aside>
<p><strong>Замечание:</strong> <code>this</code> <strong>нельзя</strong> использовать внутри литералов <code>{}</code> (<code>Object</code>) для создания ссылки на сам объект. Т.е. если мы напишем <code>var obj = {me: this}</code>, то <code>me</code> не будет ссылаться на <code>obj</code>, поскольку <code>this</code> присваивается только по одному из пяти описанных правил.</p>
</aside>
<h3 id="-">Наиболее распространенные ловушки</h3>
<p>Хотя большинство из примеров ниже имеют смысл, первый из них можно причислить к упущениям в самом языке, поскольку он <strong>вообще</strong> не имеет практического применения.</p>
<pre><code>Foo.method = function() {
    function test() {
        // this ссылается на глобальный объект
    }
    test();
};</code></pre>
<p>Распространено заблуждение в том, что <code>this</code> внутри <code>test</code> ссылается на <code>Foo</code>, но это совсем <strong>не так</strong>.</p>
<p>Для того, чтобы получить доступ к <code>Foo</code> внутри функции <code>test</code>, необходимо создать локальную переменную внутри <code>method</code>, которая и будет ссылаться на <code>Foo</code>.</p>
<pre><code>Foo.method = function() {
    var that = this;
    function test() {
        // Здесь используем that вместо this
    }
    test();
};</code></pre>
<p>Подходящее имя для такой переменной — <code>that</code>, и его часто используют для ссылки на внешний <code>this</code>. В комбинации с <a href="#function.closures">замыканиями</a> такая переменная может использоваться, чтобы «пробрасывать» <code>this</code> в глобальную область или в любой другой объект.</p>
<h3 id="-">Присвоение методов</h3>
<p>Еще одной возможностью, которая могла бы работать, но <strong>не</strong> работает в <code>JavaScript</code>, является создание псевдонимов (алиасов) для методов, т.е. <strong>присвоение</strong> метода объекта переменной.</p>
<pre><code>var test = someObject.methodTest;
test();</code></pre>
<p>Следуя первому правилу, <code>test</code> вызывается как обычная функция; следовательно <code>this</code> внутри него больше не ссылается на <code>someObject</code>.</p>
<p>Хотя позднее связывание <code>this</code> на первый взгляд может показаться не очень хорошей идеей, на самом деле это именно то, благодаря чему работает <a href="#object.prototype">наследование прототипов</a>.</p>
<pre><code>function Foo() {}
Foo.prototype.method = function() {};

function Bar() {}
Bar.prototype = Foo.prototype;

new Bar().method();</code></pre>
<p>В момент, когда будет вызван <code>method</code> нового экземпляра <code>Bar</code>, <code>this</code> будет ссылаться на этот самый экземпляр.</p>
<p>(<em>прим. перев.</em> — В случае, если вам необходимо передать <code>this</code> в функцию, вы можете использовать <code>&lt;function&gt;.call</code>, <code>&lt;function&gt;.apply</code> при непосредственно вызове или <code>&lt;function&gt;.bind</code> при отложенном — для того, чтобы вызвать эту функцию с указанным <code>this</code> в другом месте кода.)</p>
</div></article><article id="function.closures"><h2>Замыкания и ссылки</h2><div><p>Одним из самых мощных инструментов языка JavaScript считают возможность создавать <em>замыкания</em>. Это такой приём, когда новые области видимости (например, функций) <strong>постоянно</strong> имеют доступ к внешней области, в которой они были объявлены. Собственно, единственный механизм создания областей видимости в JavaScript — это и есть <a href="#function.scopes">функции</a>: таким образом, объявляя функцию, вы автоматически реализуете замыкания. Или, другими словами: любая объявленная функция по умолчанию ведёт себя как замыкание.</p>
<h3 id="-">Эмуляция приватных переменных</h3>
<pre><code>function Counter(start) {
    var count = start;
    return {
        increment: function() {
            count++;
        },

        get: function() {
            return count;
        }
    }
}

var foo = Counter(4);
foo.increment();
foo.get(); // 5</code></pre>
<p>В данном примере <code>Counter</code> возвращает <strong>два</strong> замыкания: функции <code>increment</code> и <code>get</code>. Обе эти функции сохраняют внутри себя <strong>ссылку</strong> на область видимости <code>Counter</code> и, соответственно, имеют свободный доступ к переменной <code>count</code>, объявленный в этой самой области.</p>
<h3 id="-">Как работают приватные переменные</h3>
<p>Поскольку в JavaScript нельзя присваивать или ссылаться на области видимости, заполучить <code>count</code> извне — <strong>не</strong> представляется возможным. Единственный способ взаимодействовать с этой переменной — её изменение внутри двух приведённых  выше замыканий.</p>
<pre><code>var foo = new Counter(4);
foo.hack = function() {
    count = 1337;
};</code></pre>
<p>В приведенном примере мы <strong>не</strong> изменяем переменную <code>count</code> из области видимости <code>Counter</code>, т.к. <code>foo.hack</code> не объявлен в <strong>той же</strong> области. Вместо этого будет создана или перезаписана <em>глобальная</em> переменная <code>count</code> (<em>прим. перев.</em> — замена кода внутри <code>foo.hack</code> на <code>this.count = 1337</code>, не поможет, конечно же, тоже, поскольку <code>count</code> никогда не был свойством объекта <code>Counter</code>, а был лишь внутренней переменной);</p>
<h3 id="-">Замыкания внутри циклов</h3>
<p>Существует одна ловушка, которую можно встретить довольно часто — когда замыкания используют внутри циклов, передавая переменную индекса внутрь.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout(function() {
        console.log(i);
    }, 1000);
}</code></pre>
<p>Данный код <strong>не</strong> будет выводить числа с <code>0</code> до <code>9</code> — вместо этого число <code>10</code> будет выведено десять раз.</p>
<p><em>Анонимная</em> функция сохраняет лишь <strong>ссылку</strong> на <code>i</code> — и в тот момент, когда будет вызвана функция <code>console.log</code>, цикл <code>for</code> уже давно <em>завершит</em> свою работу — и именно поэтому в переменной <code>i</code> уже будет покоиться последнее значение <code>10</code>.</p>
<p>Для получения желаемого результата необходимо создать <strong>копию</strong> переменной <code>i</code>.</p>
<h3 id="-">Обход проблемы со ссылкой</h3>
<p>Для того, чтобы скопировать значение индекса из цикла, лучше всего использовать другую <a href="#function.scopes">анонимную функцию</a> как обёртку.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    (function(e) {
        setTimeout(function() {
            console.log(e);
        }, 1000);
    })(i);
}</code></pre>
<p>Анонимная функция-обертка вызывается сразу же, и в качестве первого аргумента получает индекс <code>i</code>, <strong>значение</strong> которого будет скопировано в параметр <code>e</code>.</p>
<p>Анонимная функция, которая передается в <code>setTimeout</code>, теперь содержит ссылку на переменную <code>e</code>, значение которой <strong>не</strong> изменяется циклом.</p>
<p>Этот приём можно реализовать и другим способом — возвратив нужную функции из анонимной функции-обертки — поведение такого кода будет идентично поведению кода из предыдущего примера.</p>
<pre><code>for(var i = 0; i &lt; 10; i++) {
    setTimeout((function(e) {
        return function() {
            console.log(e);
        }
    })(i), 1000)
}</code></pre>
<p><em>Прим, перев.</em> В качестве упражнения на замыкания и анонимные функции, попробуйте заменить оборачивающие вызовы анонимных функций в примерах на варианты с <code>.call</code> и <code>.apply</code>.</p>
</div></article><article id="function.arguments"><h2>Объект <code>arguments</code></h2><div><p>В области видимости любой функции в JavaScript есть доступ к специальной переменной <code>arguments</code>. Эта переменная содержит в себе список всех аргументов, переданных данной функции.</p>
<aside>
<p><strong>Замечание:</strong> В случае, если переменная <code>arguments</code> уже была объявлена в области видимости функции либо путём присвоения через выражение <code>var</code>, либо являясь формальным параметром, объект <code>arguments</code> не будет создан.</p>
</aside>
<p>Объект <code>arguments</code> <strong>не</strong> является ни экземпляром, ни наследником <code>Array</code>. Он, конечно же, очень похож на массив, и даже обладает свойством <code>length</code> — но он не наследует <code>Array.prototype</code>, и если внимательно присмотреться, он окажется обычным <code>Object</code>.</p>
<p>По этой причине, у объекта <code>arguments</code> <strong>отсутствуют</strong> стандартные методы массивов, такие как <code>push</code>, <code>pop</code> или <code>slice</code>. Пусть перебор с использованием обычного цикла <code>for</code> по аргументам работает вполне корректно, но вам придётся конвертировать этот объект в настоящий массив типа <code>Array</code>, чтобы обрести возможность применять к нему стандартные методы массивов.</p>
<h3 id="-">Преобразование в массив</h3>
<p>Этот код вернёт новый массив типа <code>Array</code>, содержащий все элементы объекта <code>arguments</code>.</p>
<pre><code>Array.prototype.slice.call(arguments);</code></pre>
<p>Будьте внимательны — это преобразование занимает <strong>много времени</strong> и поэтому <strong>не рекомендуется</strong> использовать его в чувствительных к производительности частях кода.</p>
<h3 id="-">Передача аргументов</h3>
<p>Ниже представлен рекомендуемый способ передачи аргументов из одной функции в другую.</p>
<pre><code>function foo() {
    bar.apply(null, arguments);
}
function bar(a, b, c) {
    // делаем здесь что-нибудь
}</code></pre>
<p>Другой трюк — использовать и <code>call</code> и <code>apply</code> вместе, чтобы создать обёртку, отвязанную от объекта, и при этом выполняющуюся приемлемо быстро:</p>
<pre><code>function Foo() {}

Foo.prototype.method = function(a, b, c) {
    console.log(this, a, b, c);
};

// Создаём несвязанную версию метода
// Она принимает параметры: this, arg1, arg2...argN
Foo.method = function() {

    // Результат: Foo.prototype.method.call(this, arg1, arg2... argN)
    Function.call.apply(Foo.prototype.method, arguments);

};</code></pre>
<h3 id="-">Формальные аргументы и индексы аргументов</h3>
<p>Объект <code>arguments</code> создаёт по одному <em>геттеру</em> и по одному <em>сеттеру</em> как для всех своих свойств, так и для формальных параметров функции.</p>
<p>В результате, изменение формального параметра повлечёт за собой изменение значения соответствующего свойства объекта <code>arguments</code> и наоборот.</p>
<pre><code>function foo(a, b, c) {
    arguments[0] = 2;
    a; // 2

    b = 4;
    arguments[1]; // 4

    var d = c;
    d = 9;
    c; // 3
}
foo(1, 2, 3);</code></pre>
<h3 id="-">Разоблачение мифов о производительности</h3>
<p>Объект <code>arguments</code> создаётся во всех случаях, за одним лишь исключением — когда он переопределён по имени внутри функции, или когда одним из её параметров является переменная с таким именем. При этом ееважно, используется ли сам объект в коде функции или нет.</p>
<p><em>Геттеры</em> и <em>сеттеры</em> создаются <strong>всегда</strong>; так что их использование практически никак не влияет на производительность, и тем более никак не влияет на неё в реальном коде, где обычно происходят вещи посерьёзнее обычных прочтений и переопределений свойств объекта <code>arguments</code>.</p>
<aside>
<p><strong>Замечание по ES5:</strong> Эти <em>геттеры</em> и <em>сеттеры</em> не создаются в strict-режиме.</p>
</aside>
<p>Однако, есть одна такая тайна, что её незнание может радикально понизить производительность кода в современных движках JavaScript. Эта тайна — опасность использования <code>arguments.callee</code>.</p>
<pre><code>function foo() {
    arguments.callee; // сделать что-либо с этим объектом функции
    arguments.callee.caller; // и с вызвавшим его объектом функции
}

function bigLoop() {
    for(var i = 0; i &lt; 100000; i++) {
        foo(); // должна была бы «развернуться»
    }
}</code></pre>
<p>В коде выше, функция <code>foo</code> не может <a href="http://en.wikipedia.org/wiki/Inlining">быть «развёрнута»</a> (а могла бы), потому что для корректной работы ей необходима ссылка как на себя, так и на вызвавший её объект. Такой код не только кладёт на лопатки механизм развёртывания, но и нарушает принцип инкапсуляции, поскольку функция становится зависима от конкретного контекста вызова.</p>
<p><strong>Крайне не рекомендуется</strong> использовать <code>arguments.callee</code> или какое-либо из его свойств. <strong>Никогда</strong>.</p>
<aside>
<p><strong>Замечание по ES5:</strong> В strict-режиме любое использование <code>arguments.callee</code> вызовет <code>TypeError</code>, поскольку свойство принято устаревшим.</p>
</aside>
</div></article><article id="function.constructors"><h2>Конструктор</h2><div><p> Конструкторы в JavaScript тоже ведут себя не так, как в большинстве языков. Любая функция, вызванная с использованием ключевого слова <code>new</code>, станет конструктором.</p>
<p>Внутри конструктора (вызываемой функции) <code>this</code> будет указывать на созданный <code>Object</code>. <a href="#object.prototype">Прототипом</a> этого <strong>нового</strong> экземпляра будет <code>prototype</code> функции, вызванной под именем конструктора.</p>
<p>Если вызываемая функция не возвращает явного значения при помощи <code>return</code>, она автоматически вернёт <code>this</code> — тот самый новый экземпляр.</p>
<pre><code>function Foo() {
    this.bla = 1;
}

Foo.prototype.test = function() {
    console.log(this.bla);
};

var test = new Foo();</code></pre>
<p>В этом примере <code>Foo</code> вызывается в виде конструктора, следовательно прототип созданного объекта будет привязан к <code>Foo.prototype</code>.</p>
<p>В случае, когда функция в явном виде возвращает некое значение, при выполнении конструктора мы получим именно это значение, <strong>но только</strong> если возвращаемое значение представляет собой <code>Object</code>.</p>
<pre><code>function Bar() {
    return 2;
}
new Bar(); // новый объект

function Test() {
    this.value = 2;

    return {
        foo: 1
    };
}
new Test(); // возвращённый объект</code></pre>
<p>Если же опустить ключевое слово <code>new</code>, то функция <strong>не</strong> будет возвращать объекта.</p>
<pre><code>function Foo() {
    this.bla = 1; // свойство bla устанавливается глобальному объекту
}
Foo(); // возвращает undefined</code></pre>
<p>Хотя этот пример и будет работать — в связи со сложным поведением <a href="#function.this"><code>this</code></a> в JavaScript, значение будет присвоено <em>глобальному объекту</em> — навряд ли это то, что предполагалось автором.</p>
<h3 id="-">Фабрики</h3>
<p>Если вы хотите предоставить возможность опускать оператор <code>new</code> при создании объектов, возвращайте из соответствующего конструктора явное значение посредством <code>return</code>.</p>
<pre><code>function Bar() {
    var value = 1;
    return {
        method: function() {
            return value;
        }
    }
}
Bar.prototype = {
    foo: function() {}
};

new Bar();
Bar();</code></pre>
<p>В обоих случаях при вызове <code>Bar</code> мы получим один и тот же результат — новый объект со свойством <code>method</code>, являющимся <a href="#function.closures">замыканием</a>).</p>
<p>Ещё следует заметить, что вызов <code>new Bar()</code> никак <strong>не</strong> воздействует на прототип возвращаемого объекта. Хоть прототип и назначается всем новосозданным объектам, <code>Bar</code> никогда не возвращает этот новый объект (<em>прим. перев.</em> — судя по всему, подразумевается, что код <code>Bar</code> не может влиять на прототип созданного объекта, и под словами «новый объект» в последнем случае кроется прототип нового объекта, а не сам новый объект).</p>
<p>В предыдущем примере нет никаких функциональных различий между вызовом конструктора с оператором <code>new</code> и вызовом без него.</p>
<h3 id="-">Создание объектов с использованием фабрик</h3>
<p>Многие рекомендуют <strong>не</strong> использовать оператор <code>new</code> вовсе — аргументируя это тем, что если вы забудете его написать, такое «необдуманное» действие может «неизбежно» привести к ошибкам.</p>
<p>Чтобы создать новый объект, нам предлагают использовать фабрику и создать новый объект <em>внутри</em> этой фабрики.</p>
<pre><code>function Foo() {
    var obj = {};
    obj.value = &#39;blub&#39;;

    var private = 2;
    obj.someMethod = function(value) {
        this.value = value;
    }

    obj.getPrivate = function() {
        return private;
    }
    return obj;
}</code></pre>
<p>Хотя данный пример и сработает, когда вы забыли ключевое слово <code>new</code>, да и благодаря ему вам действительно станет легче работать с <a href="#function.closures">приватными переменными</a>, у него есть несколько недостатков:</p>
<ol>
<li>Он использует больше памяти, поскольку созданные объекты <strong>не</strong> хранят методы в прототипе и соответственно для каждого нового объекта создаётся копия каждого метода;</li>
<li>Чтобы эмулировать наследование, фабрике нужно скопировать все методы из другого объекта или установить прототипом нового объекта старый;</li>
<li>Разрыв цепочки прототипов по надуманной необходимости избавиться от использования ключевого слова <code>new</code>, идёт вразрез с духом языка;</li>
</ol>
<h3 id="-">Заключение</h3>
<p>Хотя забытое ключевое слово <code>new</code> и правда может привести к багам, это точно <strong>не</strong> причина отказываться от использования прототипов. В конце концов, полезнее решить, какой из способов лучше совпадает с требованиями приложения: крайне важно выбрать один из стилей создания объектов и после этого <strong>не изменять</strong> ему.</p>
</div></article><article id="function.scopes"><h2>Области видимости и пространства имён</h2><div><p>Хотя JavaScript вполне нормально воспринимает синтаксис двух сопоставимых фигурных скобок, окружающих блок, он <strong>не</strong> поддерживает блочную область видимости; всё, что остаётся на этот случай в языке — <em>области видимости функций</em>.</p>
<pre><code>function test() { // область видимости
    for(var i = 0; i &lt; 10; i++) { // не область видимости
        // считаем
    }
    console.log(i); // 10
}</code></pre>
<aside>
<p><strong>Замечание:</strong> Нотация <code>{...}</code> будет интерпретирована как блочное выражение, а <strong>не</strong> как литерал объекта, если она не используется в присваивании, операторе <code>return</code> или в качестве определения функции. Это замечание, вкупе с <a href="#core.semicolon">автоматической расстановкой точек с запятой</a>, может привести к чрезвычайно изощрённым ошибкам.</p>
</aside>
<p>Также JavaScript не различает пространств имён: всё определяется на том или ином уровне в единственном <em>глобально доступном</em> пространстве имён.</p>
<p>Каждый раз, когда JavaScript обнаруживает ссылку на переменную, он будет искать её всё выше и выше по областям видимости, пока не найдёт её. В случае, если он достигнет глобальной области видимости и не найдет запрошенное имя и там тоже, он выбросит <code>ReferenceError</code>.</p>
<h3 id="-">Проклятие глобальных переменных</h3>
<pre><code>// скрипт A
foo = &#39;42&#39;;

// скрипт B
var foo = &#39;42&#39;</code></pre>
<p>Вышеприведённые два скрипта отнюдь <strong>не</strong> приводят к одинаковому результату. Скрипт A определяет переменную по имени <code>foo</code> в <em>глобальной</em> области видимости, а скрипт B определяет <code>foo</code> в текущей области видимости.</p>
<p>Повторимся, это <strong>совсем не</strong> <em>тот же самый эффект</em>. Если вы не используете <code>var</code> — вы в большой опасности.</p>
<pre><code>// глобальная область видимости
var foo = 42;
function test() {
    // локальная область видимости
    foo = 21;
}
test();
foo; // 21</code></pre>
<p>Из-за того, что оператор <code>var</code> был опущен внутри функции, функция <code>test</code> перезапишет значение <code>foo</code>. Это поначалу может показаться не такой уж и большой проблемой, но если у вас имеется тысяча строк JavaScript-кода и вы не используете <code>var</code>, то вам на пути встретятся самые страшные и трудноотлаживаемые ошибки — и это не шутка.</p>
<pre><code>// глобальная область видимости
var items = [/* какой-то список */];
for(var i = 0; i &lt; 10; i++) {
    subLoop();
}

function subLoop() {
    // область видимости subLoop
    for(i = 0; i &lt; 10; i++) { // пропущен оператор var
        // происходят волшебные вещи!
    }
}</code></pre>
<p>Внешний цикл прекратит работу сразу после первого вызова <code>subLoop</code>, поскольку <code>subLoop</code> перезаписывает глобальное значение переменной <code>i</code>. Использование <code>var</code> во втором цикле <code>for</code> могло бы легко избавить вас от этой ошибки. <strong>Никогда</strong> не забывайте использовать <code>var</code>, если только вы не <em>осознано намеренны</em> повлиять на внешнюю область видимости.</p>
<h3 id="-">Локальные переменные</h3>
<p>Единственный источник локальных переменных в JavaScript - это параметры <a href="#function.general">функций</a> и переменные, объявленные с использованием оператора <code>var</code>.</p>
<pre><code>// глобальная область видимости
var foo = 1;
var bar = 2;
var i = 2;

function test(i) {
    // локальная область видимости для функции test
    i = 5;

    var foo = 3;
    bar = 4;
}
test(10);</code></pre>
<p>В то время как <code>foo</code> и <code>i</code> — локальные переменные в области видимости функции <code>test</code>, присвоение <code>bar</code> переопределит значение одноимённой глобальной переменной.</p>
<h3 id="-">Всплытие</h3>
<p>В JavaScript действует механизм <strong>всплытия</strong> (или <em>вытягивания</em>) определения. Это значит, что оба определения с использованием <code>var</code> и определение <code>function</code> будут перенесены наверх из заключающей их области видимости.</p>
<pre><code>bar();
var bar = function() {};
var someValue = 42;

test();
function test(data) {
    if (false) {
        goo = 1;

    } else {
        var goo = 2;
    }
    for(var i = 0; i &lt; 100; i++) {
        var e = data[i];
    }
}</code></pre>
<p>Этот код трансформируется ещё перед исполнением. JavaScript перемещает операторы <code>var</code> и определение <code>function</code> наверх ближайшей оборачивающей области видимости.</p>
<pre><code>// выражения с var переместились сюда
var bar, someValue; // по умолчанию - &#39;undefined&#39;

// определение функции тоже переместилось
function test(data) {
    var goo, i, e; // упущенная область видимости
                   // переместила их сюда
    if (false) {
        goo = 1;

    } else {
        goo = 2;
    }
    for(i = 0; i &lt; 100; i++) {
        e = data[i];
    }
}

bar(); // вылетает с ошибкой TypeError,
       // поскольку bar всё ещё &#39;undefined&#39;
someValue = 42; // присвоения не подвержены всплытию
bar = function() {};

test();</code></pre>
<p>Потерянная область видимости не только переместит операторы <code>var</code> вовне циклов и их тел, но и лишит смысла конструкцию c <code>if</code>.</p>
<p>Предполагалось, что в исходном коде оператор <code>if</code> изменял <em>глобальную переменную</em> <code>goo</code>, однако, как оказалось, он изменял <em>локальную переменную</em> — в результате работы всплытия.</p>
<p>Если вы не имели дела с <em>всплытием</em>, то можете предположить, что нижеприведённый код должен выбросить <code>ReferenceError</code>.</p>
<pre><code>// проверить, проинициализована ли SomeImportantThing
if (!SomeImportantThing) {
    var SomeImportantThing = {};
}</code></pre>
<p>Но, конечно же, этот код работает: из-за того, что оператор <code>var</code> был перемещён наверх <em>глобальной области видимости</em></p>
<pre><code>var SomeImportantThing;

// другой код может инициализировать здесь переменную SomeImportantThing,
// а может и нет

// убедиться, что она всё ещё здесь
if (!SomeImportantThing) {
    SomeImportantThing = {};
}</code></pre>
<h3 id="-">Порядок разрешения имён</h3>
<p>Все области видимости в JavaScript, включая <em>глобальную область видимости</em>, содержат специальную, определённую внутри них, переменную <a href="#function.this"><code>this</code></a>, которая ссылается на <em>текущий объект</em>.</p>
<p>Области видимости функций также содержат внутри себя переменную <a href="#function.arguments"><code>arguments</code></a>, которая содержит аргументы, переданные в функцию.</p>
<p>Например, когда JavaScript пытается получить доступ к переменной <code>foo</code> в области видимости функции, он будет искать её по имени в такой последовательности:</p>
<ol>
<li>Если в текущей области видимости есть выражение <code>var foo</code>, использовать эту переменную;</li>
<li>Если один из параметров функции называется <code>foo</code>, использовать этот параметр;</li>
<li>Если функция сама называется <code>foo</code>, использовать её;</li>
<li>Перейти на одну область видимости выше и повторить, начиная с <strong>п. 1</strong>;</li>
</ol>
<aside>
<p><strong>Замечание:</strong> Наличие параметра функции с именем <code>arguments</code> <strong>запрещает</strong> движку создать объект <code>arguments</code>, создающийся, в других случаях, по умолчанию.</p>
</aside>
<h3 id="-">Пространства имён</h3>
<p>Нередко можно столкнуться с таким неприятным последствием единого глобального пространства имён, как проблема с перекрытием имён переменных. В JavaScript эту проблему легко избежать, используя <em>анонимные обёртки</em>.</p>
<pre><code>(function() {
    // самодостаточное «пространство имён»

    window.foo = function() {
        // открытое замыкание
    };

})(); // сразу же выполнить функцию</code></pre>
<p>Безымянные функции являются отложенными <a href="#function.general">выражениями</a> (<em>прим. перев.</em> — то есть они не выполняются по месту описания, а откладываются движком напоследок); поэтому, чтобы сделать их исполняемыми, сначала следует спровоцировать их разбор.</p>
<pre><code>( // разобрать функцию внутри скобок
function() {}
) // и вернуть объект функции
() // вызвать результат разбора</code></pre>
<p>Есть другие способы спровоцировать разбор и последующий вызов выражения с функцией; они, хоть и различаются синтаксисом, действуют одинаково:</p>
<pre><code>// Два других способа
+function(){}();
(function(){}());</code></pre>
<!--

> **На заметку:** &#39;&#39;прим. перев.&#39;&#39; в JavaScript кроме прочего существует конструкция `new function() {}`, она очень редко используется, но позволяет создать **новый экземпляр** анонимной функции. Например, если вы присваивате нескольким объектам одну и ту же анонимную функцию-конструктор, то `instanceof` перестаёт работать, здесь вам и поможет `new function()`.

-->

<h3 id="-">Заключение</h3>
<p>Рекомендуется всегда использовать <em>анонимную обёртку</em>, чтобы заключить код в собственное пространство имён. Это не только защищает ваш код от совпадений имён, но и позволяет создавать модульные программы.</p>
<p>Важно добавить, что использование глобальных переменных считается <strong>плохой практикой</strong>. <strong>Любое</strong> их использование демонстрирует плохое качество кода, предполагает его высокую подверженность ошибкам и сложность его разбора.</p>
</div></article></section><section id="array"><!-- Introduction--><header id="array.intro"><h1>Массивы</h1></header><!-- Articles--><article id="array.general"><h2>Перебор массивов и свойств объектов</h2><div><p>Несмотря на то, что массивы в JavaScript являются объектами, <strong>не существует</strong> достаточных оснований использовать <a href="#object.forinloop">цикл <code>for in</code></a> для перебора элементов массива. Наоборот, существует множество весомых причин <strong>против</strong> использования циклов <code>for in</code> при переборе массивов.</p>
<aside>
<p><strong>Замечание:</strong> Массивы в JavaScript <strong>не</strong> являются <em>ассоциативными массивами</em>. Для группировки ключей и значений по парам в JavaScript есть только <a href="#object.general">объекты</a>. При этом, ассоциативные массивы по определению <strong>сохраняют</strong> заданный порядок свойств, объекты JavaScript этого <strong>не</strong> делают.</p>
</aside>
<p>Поскольку во время выполнения <code>for in</code> циклически перебираются все свойства объекта, находящиеся в его цепочке прототипов, а единственный способ исключить ненужные свойства — использовать <a href="#object.hasownproperty"><code>hasOwnProperty</code></a> — в действии такой цикл <strong>до 20 раз</strong> медленнее обычного цикла <code>for</code>.</p>
<h3 id="-">Итерирование</h3>
<p>Наилучшей производительности при переборе массивов можно достичь используя обычный цикл <code>for</code>.</p>
<pre><code>var list = [1, 2, 3, 4, 5, ...... 100000000];
for(var i = 0, l = list.length; i &lt; l; i++) {
    console.log(list[i]);
}</code></pre>
<p>В примере выше есть один дополнительный приём, которым кэшируется длина массива: <code>l = list.length</code>.</p>
<p>Несмотря на то, что свойство <code>length</code> определено в самом массиве, поиск этого свойства в прототипе объекта накладывает дополнительные расходы на каждую итерацию цикла. Да, в этом случае современные движки JavaScript и <strong>теоретически</strong> могут применить оптимизацию, но нет способа предугадать наверняка, будет ли оптимизирован код на используемом движке, или нет.</p>
<p>Фактически, цикл без кэширования может выполняться в <strong>два раза медленнее</strong>, нежели цикл с закэшированной длиной.</p>
<h3 id="-length-">Свойство <code>length</code></h3>
<p>Хотя <em>геттер</em> свойства <code>length</code> просто возвращает количество элементов содержащихся в массиве, его <em>сеттер</em> можно использовать для <strong>обрезания</strong> массива.</p>
<pre><code>var foo = [1, 2, 3, 4, 5, 6];
foo.length = 3;
foo; // [1, 2, 3]

foo.length = 6;
foo; // [1, 2, 3]</code></pre>
<p>Присвоение свойству <code>length</code> величины, меньшей чем текущая его длина, урезает массив, однако присвоение большего значения не производит никакого эффекта.</p>
<h3 id="-">Заключение</h3>
<p>Для оптимальной работы кода рекомендуется всегда использовать обычный цикл <code>for</code> и кэшировать свойство <code>length</code>. Использование <code>for in</code> с массивами является признаком плохого кода, содержащего потенциальные ошибки, а также приводит к низкой скорости его выполнения.</p>
</div></article><article id="array.constructor"><h2>Конструктор <code>Array</code></h2><div><p>Так как в конструкторе <code>Array</code> есть некоторая двусмысленность, касающаяся его параметров, настоятельно рекомендуется при создании массивов всегда использовать синтаксис литеральной нотации — <code>[]</code>.</p>
<pre><code>[1, 2, 3]; // Результат: [1, 2, 3]
new Array(1, 2, 3); // Результат: [1, 2, 3]

[3]; // Результат: [3]
new Array(3); // Результат: []
new Array(&#39;3&#39;) // Результат: [&#39;3&#39;]</code></pre>
<p>В ситуации, когда в конструктор <code>Array</code> передаётся только один аргумент, и этот аргумент имеет тип <code>Number</code> — конструктор возвращает новый, <em>разреженный</em> (<em>прим. перев.</em> — <em>заполненный случайными значениями</em>) массив, имеющий длину, равную значению переданного аргумента. Стоит заметить, что в этом случае будет установлено лишь свойство <code>length</code> нового массива, а реальные индексы массива не будут инициализированы.</p>
<pre><code>var arr = new Array(3);
arr[1]; // не определён, undefined
1 in arr; // false, индекс не был установлен</code></pre>
<p>Поведение, позволяющее заранее установить размер массива, может пригодиться лишь в некоторых случаях — например, для повторения строки — так вы сможете не использовать цикл <code>for</code>.</p>
<pre><code>new Array(count + 1).join(stringToRepeat);</code></pre>
<h3 id="-">Заключение</h3>
<p>Использования конструктора <code>Array</code> нужно избегать. Литералы, безусловно, намного предпочтительнее — это краткая запись, её синтаксис «чище» — а это, в свою очередь повышает, читабельность кода.</p>
</div></article></section><section id="types"><!-- Introduction--><header id="types.intro"><h1>Типы</h1></header><!-- Articles--><article id="types.equality"><h2>Равенство и сравнения</h2><div><p>JavaScript умеет сравнивать значения объектов на равенство двумя различными способами.</p>
<h3 id="-">Оператор сравнения</h3>
<p>Оператор сравнения состоит из <strong>двух</strong> символов равенства: <code>==</code></p>
<p>Под <em>слабой типизацией</em> языка JavaScript подразумевается <strong>приведение</strong> обеих переменных к <strong>одному типу</strong> при сравнении двух объектов.</p>
<pre><code>&quot;&quot;           ==   &quot;0&quot;           // false
0            ==   &quot;&quot;            // true
0            ==   &quot;0&quot;           // true
false        ==   &quot;false&quot;       // false
false        ==   &quot;0&quot;           // true
false        ==   undefined     // false
false        ==   null          // false
null         ==   undefined     // true
&quot; \t\r\n&quot;    ==   0             // true</code></pre>
<p>В таблице выше показаны результаты приведения типов в разных ситуациях и показана главная причина, по которой использование <code>==</code> повсеместно считается плохой практикой: «благодаря» непредсказуемости правил преобразования типов, становится очень трудно искать причины возникновения ошибок.</p>
<p>Кроме того, приведение типов во время сравнения вынужденно влияет на производительность; например, строка должна быть преобразована в число перед сравнением с другим числом.</p>
<h3 id="-">Оператор строгого равенства</h3>
<p>Оператор строгого равенства состоит из <strong>трёх</strong> символов равенства: <code>===</code></p>
<p>Он работает так же, как и обычный оператор сравнения, но оператор строгого равенства <strong>не</strong> выполняет приведения типов между своими операндами.</p>
<pre><code>&quot;&quot;           ===   &quot;0&quot;           // false
0            ===   &quot;&quot;            // false
0            ===   &quot;0&quot;           // false
false        ===   &quot;false&quot;       // false
false        ===   &quot;0&quot;           // false
false        ===   undefined     // false
false        ===   null          // false
null         ===   undefined     // false
&quot; \t\r\n&quot;    ===   0             // false</code></pre>
<p>Результаты выше немного более предсказуемы и помогают быстрее выявлять ошибки в коде. Использование этого оператора в определённой степени делает код надёжнее, а кроме того обспечивает прирост производительности в случае, если типы операндов различны.</p>
<h3 id="-">Сравнение объектов</h3>
<p>Хотя оба оператора <code>==</code> и <code>===</code> заявлены как операторы равенства, они ведут себя по-разному, когда хотя бы одним из операндов оказывается <code>Object</code>.</p>
<pre><code>{} === {};                   // false
new String(&#39;foo&#39;) === &#39;foo&#39;; // false
new Number(10) === 10;       // false
var foo = {};
foo === foo;                 // true</code></pre>
<p>Здесь оба операнда сравниваются на <strong>идентичность</strong>, а <strong>не</strong> на равенство; то есть будет проверяться, являются ли операнды одним и тем же <strong>экземпляром</strong> объекта — так же, как делает <code>is</code> в Python или сравниваются указатели в С.</p>
<h3 id="-">Заключение</h3>
<p>Крайне рекомендуется использовать только операторы <strong>строгого равенства</strong>. В случаях, когда необходимо использовать преобразование типов, нужно сделать <a href="#types.casting">явное приведение</a>, а не оставлять его на совести нарочито мудрых языковых операций.</p>
</div></article><article id="types.typeof"><h2>Оператор <code>typeof</code></h2><div><p>Оператор <code>typeof</code> (вместе с <a href="#types.instanceof"><code>instanceof</code></a>) — это, вероятно, самая большая недоделка в JavaScript, поскольку с накоплением нашего опыта выясняется, что он <strong>поломан, разве что не полностью</strong>.</p>
<p>Учитывая, что число потенциальных поводов для применения <code>instanceof</code> довольно ограничено, важно отметить, что <code>typeof</code> вообще имеет <em>один-единственный</em> практический случай применения, который при всём при этом, неожиданно,.. <strong>не</strong> оказывается проверкой типа объекта.</p>
<aside>
<p><strong>Замечание:</strong> Хотя для вызова <code>typeof</code> также можно использовать синтаксис функции, т.е. <code>typeof(obj)</code>, на самом деле это вовсе не функция. Да — двойные круглые скобки будут работать нормально и возвращаемое значение будет использоваться как операнд оператора <code>typeof</code>, но функции <code>typeof</code> — <strong>не существует</strong>.</p>
</aside>
<h3 id="-javascript">Таблица типов JavaScript</h3>
<pre><code>Значение            Класс      Тип
-------------------------------------
&quot;foo&quot;               String     string
new String(&quot;foo&quot;)   String     object
1.2                 Number     number
new Number(1.2)     Number     object
true                Boolean    boolean
new Boolean(true)   Boolean    object
new Date()          Date       object
new Error()         Error      object
[1,2,3]             Array      object
new Array(1, 2, 3)  Array      object
new Function(&quot;&quot;)    Function   function
/abc/g              RegExp     object (function в Nitro/V8)
new RegExp(&quot;meow&quot;)  RegExp     object (function в Nitro/V8)
{}                  Object     object
new Object()        Object     object</code></pre>
<p>В этой таблице в колонке <em>Тип</em> приводится значение, возвращаемое оператором <code>typeof</code> для указанного объекта. Как хорошо заметно, это значение может оказаться чем угодно, но не ожидавшимся результатом.</p>
<p>В колонке <em>Класс</em> приведено значение внутреннего свойства объекта <code>[[Class]]</code>.</p>
<aside>
<p><strong>Из спецификации:</strong> Значением <code>[[Class]]</code> может быть одна из следующих строк: <code>Arguments</code>, <code>Array</code>, <code>Boolean</code>, <code>Date</code>, <code>Error</code>, <code>Function</code>, <code>JSON</code>, <code>Math</code>, <code>Number</code>, <code>Object</code>, <code>RegExp</code>, <code>String</code>.</p>
</aside>
<p>Чтобы получить значение <code>[[Class]]</code>, нужно применить к интересующему объекту метод <code>toString</code> из прототипа <code>Object.prototype</code>. (<em>прим. перев.</em> — то есть не вызвать метод у самого объекта, а именно применить к нему метод из прототипа, см. ниже).</p>
<h3 id="-">Класс объекта</h3>
<p>Спецификация предоставляет только один способ доступа к значению <code>[[Class]]</code> — используя <code>Object.prototype.toString</code>.</p>
<pre><code>function is(type, obj) {
    var clas = Object.prototype.toString.call(obj).slice(8, -1);
    return obj !== undefined &amp;&amp; obj !== null &amp;&amp; clas === type;
}

is(&#39;String&#39;, &#39;test&#39;); // true
is(&#39;String&#39;, new String(&#39;test&#39;)); // true</code></pre>
<p>В примере выше <code>Object.prototype.toString</code> вызывается со значением <a href="#function.this">this</a>, ссылающимся на объект, значение <code>[[Class]]</code> которого требуется получить.</p>
<aside>
<p><strong>Замечание по ES5:</strong> Для удобства, в ECMAScript 5 возвращаемое значение <code>Object.prototype.toString</code> для <code>null</code> и <code>undefined</code> было изменено с <code>Object</code> на <code>Null</code> и <code>Undefined</code> соответственно.</p>
</aside>
<h3 id="-">Проверка переменных на определённость</h3>
<pre><code>typeof foo !== &#39;undefined&#39;</code></pre>
<p>Данное выражение позволяет удостовериться, была ли объявлена переменная <code>foo</code>; явное обращение к несуществующей переменной в коде породит <code>ReferenceError</code>. И вот это — единственное, чем на самом деле полезен <code>typeof</code>.</p>
<h3 id="-">Заключение</h3>
<p>Для проверки типа объекта настоятельно рекомендуется использовать <code>Object.prototype.toString</code> — это единственный и надежный способ. Как показано выше в таблице типов, некоторые значения, возвращаемые <code>typeof</code>, не описаны в спецификации: следовательно, они могут различаться в разных реализациях движка.</p>
<p>За исключением случаев проверки, была ли определена переменная, использования <code>typeof</code> следует избегать.</p>
</div></article><article id="types.instanceof"><h2>Оператор <code>instanceof</code></h2><div><p>Оператор <code>instanceof</code> сравнивает конструкторы двух операндов. Он работает правильно только тогда, когда сравниваются пользовательские объекты. Использование его на встроенных типах практически так же бесполезно, как и использование <a href="#types.typeof">оператора typeof</a>.</p>
<h3 id="-">Сравнение пользовательских объектов</h3>
<pre><code>function Foo() {}
function Bar() {}
Bar.prototype = new Foo();

new Bar() instanceof Bar; // true
new Bar() instanceof Foo; // true

// Всего-то лишь присваиваем Bar.prototype объект функции Foo,
// а не экземпляр Foo
Bar.prototype = Foo;
new Bar() instanceof Foo; // false</code></pre>
<h3 id="-instanceof-">Использование <code>instanceof</code> со встроенными типами</h3>
<pre><code>new String(&#39;foo&#39;) instanceof String; // true
new String(&#39;foo&#39;) instanceof Object; // true

&#39;foo&#39; instanceof String; // false
&#39;foo&#39; instanceof Object; // false</code></pre>
<p>Здесь нужно отметить одну важную вещь: <code>instanceof</code> не работает с объектами, которые происходят из разных контекстов JavaScript (например, из различных документов в web-браузере), так как их конструкторы на самом деле не будут конструкторами <em>тех же самых</em> объектов, что справедливо.</p>
<h3 id="-">Заключение</h3>
<p>Оператор <code>instanceof</code> должен использоваться <strong>только</strong> при обращении к пользовательским объектам, происходящим из одного контекста JavaScript. Также, как и в случае оператора <code>typeof</code>, любого другого использования <code>instanceof</code> необходимо <strong>избегать</strong>.</p>
</div></article><article id="types.casting"><h2>Приведение типов</h2><div><p>JavaScript — язык, в котором господствует <em>слабая типизация</em>, поэтому <em>преобразование типов</em> будет применяться <strong>везде</strong>, где только возможно.</p>
<pre><code>// Эти равенства возвращают true
new Number(10) == 10; // объект типа Number преобразуется
                      // в числовой примитив в результате неявного вызова
                      // метода Number.prototype.valueOf

10 == &#39;10&#39;;           // Строки преобразуются в Number
10 == &#39;+10 &#39;;         // Ещё чуток строко-безумия
10 == &#39;010&#39;;          // и ещё
isNaN(null) == false; // null преобразуется в 0,
                      // который, конечно же, не NaN

// Эти равенства возвращают false
10 == 010;
10 == &#39;-10&#39;;</code></pre>
<aside>
<p><strong>Замечание по ES5:</strong> Числовые литералы, которые начинаются с 0, интерпретируются как восьмеричные (Base 8). В ECMAScript 5 strict mode <strong>удалена</strong> поддержка восьмеричной системы.</p>
</aside>
<p>Для того, чтобы избежать такого поведения, <strong>настоятельно</strong> рекомендуется использовать <a href="#types.equality">оператор строгого равенства</a>. Впрочем, хотя это и позволит избежать многих распространенных ошибок, существует ещё множество дополнительных проблем, возникающих по вине слабой типизации JavaScript.</p>
<h3 id="-">Конструкторы встроенных типов</h3>
<p>Конструкторы встроенных типов, например, <code>Number</code> и <code>String</code> ведут себя различным образом, в зависимости от того, вызываются они с ключевым словом <code>new</code> или без.</p>
<pre><code>new Number(10) === 10;     // False: Object и Number
Number(10) === 10;         // True: Number и Number
new Number(10) + 0 === 10; // True: из-за неявного преобразования</code></pre>
<p>Использование встроенных типов, таких как <code>Number</code>, с конструктором, создаёт новый экземпляр объекта <code>Number</code>, но использование их же без ключевого слова <code>new</code>, создаёт функцию <code>Number</code>, которая будет вести себя в равенствах в роли «преобразователя».</p>
<p>Кроме того, присутствие в равенствах дополнительных литералов или переменных, которые не являются объектами, повлечёт за собой лишь ещё большее количество бессмысленных преобразований типов.</p>
<p>Лучший вариант — это <strong>явное</strong> приведение к одному из трех возможных типов.</p>
<h3 id="-">Приведение к строке</h3>
<pre><code>&#39;&#39; + 10 === &#39;10&#39;; // true</code></pre>
<p>Путём добавления в начало пустой строки, значение легко приводится к строке.</p>
<h3 id="-">Приведение к числовому типу</h3>
<pre><code>+&#39;10&#39; === 10; // true</code></pre>
<p>Применив <strong>унарный</strong> оператор плюс, можно преобразовать значение в число.</p>
<h3 id="-">Приведение к булеву типу</h3>
<p>Использование оператора <strong>not</strong> (<code>!</code>) дважды поможет привести значение к логическому (булеву) типу.</p>
<pre><code>!!&#39;foo&#39;;   // true
!!&#39;&#39;;      // false
!!&#39;0&#39;;     // true
!!&#39;1&#39;;     // true
!!&#39;-1&#39;     // true
!!{};      // true
!!true;    // true</code></pre>
</div></article></section><section id="core"><!-- Introduction--><header id="core.intro"><h1>Ядро</h1></header><!-- Articles--><article id="core.eval"><h2>Почему нельзя использовать <code>eval</code></h2><div><p>Функция <code>eval</code> выполнит переданную строку в качестве кода JavaScript в локальной области видимости:</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    eval(&#39;foo = 3&#39;);
    return foo;
}
test(); // 3
foo; // 1</code></pre>
<p>но только тогда, когда функция <code>eval</code> вызывается явно <em>и при этом</em> имя вызываемой функции <em>идентично</em> <code>eval</code>:</p>
<pre><code>var foo = 1;
function test() {
    var foo = 2;
    var bar = eval;
    bar(&#39;foo = 3&#39;);
    return foo;
}
test(); // 2
foo; // 3</code></pre>
<p><strong>Любой ценой</strong> избегайте функции <code>eval</code>. 99.9% «трюков» с её «использованием» могут быть запросто решены и <strong>без её участия</strong>.</p>
<h3 id="-eval-"><code>eval</code> под прикрытием</h3>
<p>Обе <a href="#other.timeouts">функции работы с интервалами времени</a> <code>setTimeout</code> и <code>setInterval</code> могут принимать строку в качестве первого аргумента. Эта строка <strong>всегда</strong> будет выполняться в глобальной области видимости, поскольку <code>eval</code> в этом случае вызывается <em>неявно</em>.</p>
<h3 id="-">Проблемы с безопасностью</h3>
<p>Кроме всего прочего, функция <code>eval</code> — это дыра в безопасности, поскольку она выполняет <strong>любой</strong> переданный в неё код; <strong>никогда</strong> не используйте её со строками из неизвестных или недоверительных источников.</p>
<h3 id="-">Заключение</h3>
<p>Никогда не используйте <code>eval</code>: любой код с участием этой функции автоматически порождает вопросы о качестве его работы, производительности и безопасности. Если вдруг для работы вам необходим <code>eval</code>, эта часть кода должна тут же ставиться под сомнение и в первую очередь <em>исключаться</em> из проекта — необходимо найти <em>лучший способ</em>, которому не требуются вызовы <code>eval</code>.</p>
</div></article><article id="core.undefined"><h2><code>undefined</code> и <code>null</code></h2><div><p>В JavaScript используется два отдельных типа для описания <em>ничего</em> — <code>null</code> и <code>undefined</code>, при этом более полезным из них оказывается <code>undefined</code>.</p>
<h3 id="-undefined-">Значение <code>undefined</code></h3>
<p><code>undefined</code> — это тип с единственным возможным значением: <code>undefined</code>.</p>
<p>Кроме этого, в языке определена глобальная переменная со значением <code>undefined</code>, причём эта переменная так и называется — <code>undefined</code>. Не являясь константой, она не является и ключевым словом. Из этого следует, что её значение можно с лёгкостью переопределить.</p>
<aside>
<p><strong>Замечание по ES5:</strong> в ECMAScript 5 переменная <code>undefined</code> <strong>больше не</strong> <em>доступна на запись</em> в strict-режиме, однако она всё ещё может быть перегружена по имени, например — функцией с именем <code>undefined</code>.</p>
</aside>
<p>Список случаев, когда код возвращает значение <code>undefined</code>:</p>
<ul>
<li>При попытке доступа к глобальной переменной <code>undefined</code> (если она не была переопределена).</li>
<li>При попытке доступа к переменной, которая <em>ещё не была</em> инициализирована каким-либо значением.</li>
<li>Неявный возврат из функции при отсутствии в ней оператора <code>return</code>.</li>
<li>Из оператора <code>return</code>, который не возвращает явного значения.</li>
<li>В результате поиска несуществующего свойства у объекта (и/или доступа к нему).</li>
<li>При попытке доступа к аргументу функции, который не был передан в неё явно.</li>
<li>При попытке доступа к чему-либо, чьим значением является <code>undefined</code>.</li>
<li>В результате вычисления любого выражения, соответствующего форме <code>void(выражение)</code>.</li>
</ul>
<h3 id="-undefined-">Защита от потенциальных изменений значения <code>undefined</code></h3>
<p>Поскольку глобальная переменная <code>undefined</code> содержит копию реального <em>значения</em> <code>undefined</code>, присвоение этой переменной нового значения <strong>не</strong> изменяет значения у <em>типа</em> <code>undefined</code>.</p>
<p>Получается, чтобы проверить что-либо с <em>типом</em> <code>undefined</code> (на соответствие <em>значению</em> <code>undefined</code>), прежде нужно узнать изначальное значение самой <em>переменной</em> <code>undefined</code>.</p>
<p>Для того, чтобы защитить код от случайного переопределения переменной <code>undefined</code>, часто используют технику <a href="#function.scopes">анонимной обёртки</a>, в которую добавляют аргумент и намеренно не передают его значение.</p>
<pre><code>var undefined = 123;
(function(something, foo, undefined) {
    // в локальной области видимости `undefined`
    // снова ссылается на правильное значене.

})(&#39;Hello World&#39;, 42);</code></pre>
<p>Другой способ достичь того же эффекта — использовать определение внутри обёртки.</p>
<pre><code>var undefined = 123;
(function(something, foo) {
    var undefined;
    ...

})(&#39;Hello World&#39;, 42);</code></pre>
<p>Единственная разница между этими вариантами в том, что последняя версия при минификации будет занимать больше на 4 байта, поскольку в первом случае внутри анонимной обёртки нет дополнительного оператора <code>var</code>.</p>
<h3 id="-null-">Применение <code>null</code></h3>
<p>Хотя <code>undefined</code> в контексте языка JavaScript чаще используется в роли традиционного <em>null</em>, настоящий <code>null</code> (и тип и литерал) является, в какой-то степени, просто другим типом данных.</p>
<p>Он используется во внутренних механизмах JavaScript (в случаях вроде установки конца цепочки прототипов, через присваивание <code>Foo.prototype = null</code>). Но практически во всех случаях тип <code>null</code> может быть заменён на равносильный ему <code>undefined</code>.</p>
</div></article><article id="core.semicolon"><h2>Автоматическая вставка точек с запятой</h2><div><p>Несмотря на то, что синтаксис JavaScript подобен языкам семейства C, он <strong>не принуждает</strong> вас ставить точки с запятой в исходном коде — вам всегда позволено обойтись без них.</p>
<p>При этом JavaScript — не из тех языков, в которых отсутствуют точки с запятой: на самом деле они очень нужны ему — для того, чтобы он мог разобраться в вашем коде. Поэтому парсер JavaScript <strong>автоматически</strong> вставляет их в те места, где сталкивается с ошибкой парсинга, вызванной их отсутствием.</p>
<pre><code>var foo = function() {
} // ошибка разбора, ожидается точка с запятой
test()</code></pre>
<p>Происходит вставка и парсер пытается снова.</p>
<pre><code>var foo = function() {
}; // ошибки нет, парсер продолжает
test()</code></pre>
<p>Автоматическая вставка точек с запятой считается одним из <strong>наибольших</strong> упущений в проекте языка, поскольку такая вставка <em>действительно может</em> влиять на поведение кода.</p>
<h3 id="-">Как это работает</h3>
<p>Приведённый код не содержит точек с запятой, так что места для их вставки остаются на совести парсера:</p>
<pre><code>(function(window, undefined) {
    function test(options) {
        log(&#39;проверяем!&#39;)

        (options.list || []).forEach(function(i) {

        })

        options.value.test(
            &#39;здесь передадим длинную строчку&#39;,
            &#39;и ещё одну на всякий случай&#39;
        )

        return
        {
            foo: function() {}
        }
    }
    window.test = test

})(window)

(function(window) {
    window.someLibrary = {}

})(window)</code></pre>
<p>Ниже представлен результат игры парсера в «угадалки».</p>
<pre><code>(function(window, undefined) {
    function test(options) {

        // не вставлена точка с запятой, строки были объединены
        log(&#39;тестируем!&#39;)(options.list || []).forEach(function(i) {

        }); // &lt;- вставлена

        options.value.test(
            &#39;здесь передадим длинную строчку&#39;,
            &#39;и ещё одну на всякий случай&#39;
        ); // &lt;- вставлена

        return; // &lt;- вставлена, в результате
                //    оператор return разбит на два блока
        { // теперь парсер считает этот блок отдельным

            // метка и одинокое выражение
            foo: function() {}
        }; // &lt;- вставлена
    }
    window.test = test; // &lt;- вставлена

// снова объединились строки
})(window)(function(window) {
    window.someLibrary = {}; // &lt;- вставлена

})(window); //&lt;- вставлена</code></pre>
<aside>
<p><strong>Замечание:</strong> Парсер JavaScript некорректно обрабатывает оператор <code>return</code>, за которым следует новая строка; Причина может скрываться и не за автоматической вставкой точек с запятой — но без сомнений — этот побочный эффект нежелателен.</p>
</aside>
<p>Парсер радикально поменял поведение изначального кода, а в определённых случаях он вообще сделал <strong>абсолютно неправильные выводы</strong>.</p>
<h3 id="-">«Висящие» скобки</h3>
<p>Если парсер встречает «висящую» открывающую скобку, он <strong>не</strong> вставляет точку с запятой.</p>
<pre><code>log(&#39;тестируем!&#39;)
(options.list || []).forEach(function(i) {})</code></pre>
<p>Такой код трансформируется в одну склеенную строку.</p>
<pre><code>log(&#39;тестируем!&#39;)(options.list || []).forEach(function(i) {})</code></pre>
<p>Шансы на то, что <code>log</code> <strong>не</strong> вернёт функцию, <strong>крайне</strong> высоки; так что выполнение этой строки кода породит <code>TypeError</code>, приправив его сообщением о том, что <code>undefined не является функцией</code>.</p>
<h3 id="-">Заключение</h3>
<p>Настоятельно рекомендуем <strong>никогда</strong> не забывать ставить точку с запятой; также рекомендуется оставлять скобки на одной строке с соответствующим оператором и всегда использовать их в выражениях <code>if</code> / <code>else</code>. Оба этих совета не только повысят читабельность вашего кода, но и предотвратят вас от изменений в поведении кода, сделанных парсером без вашего ведома.</p>
</div></article><article id="core.delete"><h2>Оператор <code>delete</code></h2><div><p>Если говорить кратко — в JavaScript невозможно удалить глобальную переменную или функцию или любую другую сущность, у которой установлен атрибут <code>DontDelete</code>.</p>
<h3 id="-">Глобальный код и код внутри функций</h3>
<p>Когда переменная или функция определена в глобальной области видимости или в <a href="#function.scopes">области видимости функции</a>, её судьба предопределена: (<em>прим. перев.</em> — внутри движка JavaScript) она является свойством (<code>property</code>) либо объекта <code>Activation</code>, либо объекта <code>Global</code>. Подобные сущности имеют набор внутренних атрибутов, одним из которых и является упомянутый ранее <code>DontDelete</code>. Переменные и объявления функций, замеченные движком в глобальной области или в коде функций, создаются с атрибутом <code>DontDelete</code> и поэтому не могут быть удалены.</p>
<pre><code>// глобальная переменная:
var a = 1; // установлен DontDelete
delete a; // false
a; // 1

// обычная функция:
function f() {} // установлен DontDelete
delete f; // false
typeof f; // &quot;function&quot;

// переопределение не помогает:
f = 1;
delete f; // false
f; // 1</code></pre>
<h3 id="-">Установленные пользователем свойства</h3>
<p>Свойства, установленные явно, могут быть безпрепятственно удалены:</p>
<pre><code>// явно установим свойства:
var obj = {x: 1};
obj.y = 2;
delete obj.x; // true
delete obj.y; // true
obj.x; // undefined
obj.y; // undefined</code></pre>
<p>В приведённом примере свойства <code>obj.x</code> и <code>obj.y</code> могут быть удалены, поскольку у них отсутствует атрибут <code>DontDelete</code>. По этой же причине работает и пример ниже:</p>
<pre><code>// работает нормально, но не в IE
var GLOBAL_OBJECT = this;
GLOBAL_OBJECT.a = 1;
a === GLOBAL_OBJECT.a; // true - просто глобальная переменная
delete GLOBAL_OBJECT.a; // true
GLOBAL_OBJECT.a; // undefined</code></pre>
<p>Здесь, чтобы удалить <code>a</code>, мы используем один трюк. В этом коде <a href="#function.this"><code>this</code></a> ссылается на объект <code>Global</code> и мы явно описываем переменную <code>a</code> под видом его свойства, что и позволяет нам её успешно удалить.</p>
<p>Internet Explorer (по крайней мере, с 6-го по 8-й) содержит баги, из-за которых такой код не сработает.</p>
<h3 id="-">Аргументы функций и встроенные свойства</h3>
<p>Обычные аргументы функций, <a href="#function.arguments">объект <code>arguments</code></a>, а также встроенные свойства, объединены общей особенностью: у всех у них установен атрибут <code>DontDelete</code>.</p>
<pre><code>// аргументы функций и свойства:
(function (x) {

  delete arguments; // false
  typeof arguments; // &quot;object&quot;

  delete x; // false
  x; // 1

  function f(){}
  delete f.length; // false
  typeof f.length; // &quot;number&quot;

})(1);</code></pre>
<h3 id="-">Хост-объекты</h3>
<p>(<em>прим. перев.</em> — Хост-объекты — это объекты, которые, в неком окружении, дополняют функциональность языка JavaScript, не являясь частью его спецификации. В случае браузера это объекты <code>window</code>, <code>document</code>, <code>setTimeout</code> и т.п.)</p>
<p>Поведение оператора <code>delete</code> может быть полностью непредсказуемым, когда вы примененяете его к таким хост-объектам. С позволения спецификации, хост-объекты вольны вести себя как им только вздумается.</p>
<h3 id="-">Заключение</h3>
<p>Оператор <code>delete</code> часто ведёт себя непредсказуемо и может использоваться относительно безопасно только для удаления пользовательских свойств у обычных объектов.</p>
</div></article></section><section id="other"><!-- Introduction--><header id="other.intro"><h1>Другое</h1></header><!-- Articles--><article id="other.timeouts"><h2><code>setTimeout</code> и <code>setInterval</code></h2><div><p>В виду того, что JavaScript умеет совершать асинхронные операции, есть возможность запланировать отложенное выполнение пользовательской функции с помощью предназначенных для этого функций <code>setTimeout</code> и <code>setInterval</code>.</p>
<aside>
<p><strong>Замечание:</strong> Таймауты <strong>не</strong> являются частью стандарта ECMAScript, они были разработаны будучи частью спецификации<a href="http://ru.wikipedia.org/wiki/Document_Object_Model" title="Document Object Model">DOM</a>.</p>
</aside>
<pre><code>function foo() {}
var id = setTimeout(foo, 1000); // возвращает число &gt; 0</code></pre>
<p>Функция <code>setTimeout</code> возвращает идентификатор назначенного таймаута и откладывает вызов <code>foo</code> на, <strong>примерно</strong>, тысячу миллисекунд. Функция <code>foo</code>, при этом, будет вызвана ровно <strong>один</strong> раз.</p>
<p>В зависимости от разрешения таймера в используемом для запуска кода движке JavaScript, а также с учётом того, что JavaScript является однопоточным языком и посторонний код может заблокировать выполнение потока, нет <strong>никакой</strong> гарантии, что переданный код будет выполнен ровно через указанное в вызове <code>setTimeout</code> время.</p>
<p>Функция, переданная первым параметром, будет вызвана в контексте <em>глобального объекта</em> — это значит, что оператор <a href="#function.this"><code>this</code></a> в вызываемой функции будет ссылаться на тот самый глобальный объект.</p>
<pre><code>function Foo() {
    this.value = 42;
    this.method = function() {
        // this ссылается на глобальный объект
        console.log(this.value); // выведет в лог undefined
    };
    setTimeout(this.method, 500);
}
new Foo();</code></pre>
<aside>
<p><strong>Замечание:</strong> Поскольку <code>setTimeout</code> принимает <strong>объект функции</strong> в качестве первого параметра, часто совершается ошибка в использовании <code>setTimeout(foo(), 1000)</code>, при котором будет использоваться <strong>возвращённое значение</strong> от вызова функции <code>foo</code>, а <strong>не</strong> вызываться сама функция <code>foo</code>. В большинстве случаев ошибка пройдёт незамеченной, а в случае если функция возвращает <code>undefined</code>, <code>setTimeout</code> вообще <strong>не</strong> породит никакой ошибки.</p>
</aside>
<h3 id="-setinterval-">Очереди вызовов с <code>setInterval</code></h3>
<p><code>setTimeout</code> вызывает функцию единожды; <code>setInterval</code> — как и предполагает название — вызывает функцию <strong>каждые</strong> <code>X</code> миллисекунд. И использовать его не рекомендуется.</p>
<p>В то время как, при использовании <code>setTimeout</code>, исполняющийся в данный момент код будет блокировать запланированный — <code>setInterval</code> продолжит планировать последующие вызовы переданной функции. При указании небольших интервалов это повлечь за собой выстраивание функций в ожидающую очередь.</p>
<pre><code>function foo(){
    // что-то, выполняющееся десятую секунды или более
}
setInterval(foo, 100);</code></pre>
<p>В приведённом примере <code>foo</code> в первый же раз заблокирует своим процессом главный поток на десятую секунды.</p>
<p>Пока <code>foo</code> блокирует код, <code>setInterval</code> продолжает планировать последующие её вызовы. Теперь, когда первая <code>foo</code> закончила выполнение, в очереди будет уже <strong>десяток</strong> ожидающих выполнения вызовов <code>foo</code>.</p>
<p>(<em>прим. перев.</em> — Во времена написания и перевода этой документации не существовало функции <code>requestAnimationFrame</code>, которая не гарантирует постоянный интервал во времени, но гарантирует свободные ресурсы процессора на каждый вызов — сейчас для некоторых повторяющихся задач, даже не связанных с анимацией, используют именно её).</p>
<h3 id="-">Разбираемся с потенциальной блокировкой кода</h3>
<p>Самый простой и легко контролируемый способ — использовать <code>setTimeout</code> внутри такой функции.</p>
<pre><code>function foo(){
    // что-то, выполняющееся одну секунду или более
    setTimeout(foo, 1000);
}
foo();</code></pre>
<p>Такой способ не только инкапсулирует вызов <code>setTimeout</code>, но и предотвращает от очередей блокирующих вызовов и при этом обеспечивает дополнительный контроль: сама функция <code>foo</code> теперь принимает решение, хочет ли она запускаться ещё раз или нет.</p>
<h3 id="-">Сброс таймаутов вручную</h3>
<p>Удалить таймаут или интервал можно посредством передачи соответствующего идентификатора либо в функцию <code>clearTimeout</code>, либо в функцию <code>clearInterval</code> — в зависимости от того, какая функция <code>set...</code> использовалась для его создания.</p>
<pre><code>var id = setTimeout(foo, 1000);
clearTimeout(id);</code></pre>
<h3 id="-">Сброс всех таймаутов</h3>
<p>Из-за того, что встроенного метода для удаления всех созданных таймаутов и/или интервалов не существует, даже ради просто приемлимого достижения этой цели приходится использовать силу.</p>
<pre><code>// сбрасываем «все» таймауты
for(var i = 1; i &lt; 1000; i++) {
    clearTimeout(i);
}</code></pre>
<p>Впрочем, с таким кодом, вполне могут остаться «в живых» таймауты, которые <em>настолько</em> произвольное число не сможет охватить.</p>
<p>Есть и другой способ воплотить желаемое — условиться, что значения ID, выдающихся таймаутам, постоянно увеличиваются — с каждым новым вызовом <code>setTimeout</code>.</p>
<pre><code>// сбрасываем «все» таймауты
var biggestTimeoutId = window.setTimeout(function(){}, 1),
i;
for(i = 1; i &lt;= biggestTimeoutId; i++) {
    clearTimeout(i);
}</code></pre>
<p>Однако, даже при том, что такой код работает сегодня во всех современных браузерах, нигде не указано и не гарантируется, что значения ID всегда увеличиваются. Поэтому, всё же, рекомендуется следить за <em>каждым</em> идентификатором <em>каждого</em> создающегося таймаута —  это позволит вам уверенно контролировать процесс, сбрасывая их индивидуально.</p>
<h3 id="-eval-">Скрытое использование <code>eval</code></h3>
<p><code>setTimeout</code> и <code>setInterval</code> могут принимать строку в качестве первого параметра. Эту возможность не следует использовать <strong>никогда</strong> — по той лишь причине, что изнутри, при этом, производится скрытый вызов <code>eval</code>.</p>
<aside>
<p><strong>Замечание</strong>: Поскольку функции работы с таймаутами <strong>не</strong> определены в стандарте ECMAScript, точная внутренняя механика их работы может различаться от движка к движку. Например, Microsoft JScript использует конструктор <code>Function</code> вместо <code>eval</code>.</p>
</aside>
<pre><code>function foo() {
    // будет вызвана
}

function bar() {
    function foo() {
        // никогда не будет вызывана
    }
    setTimeout(&#39;foo()&#39;, 1000);
}
bar();</code></pre>
<p>Поскольку <code>eval</code> в этом случае не вызывается <a href="#core.eval">явно</a>, переданная в <code>setTimeout</code> строка будет выполнена в <em>глобальной области видимости</em>; так что локальная функция <code>foo</code> из области видимости <code>bar</code> вообще не будет выполнена.</p>
<p>По этим же причинам <strong>не рекомендуется</strong> использовать строковое представление вызова функции для передачи аргументов в функцию, которая должна быть вызвана одним из двух известных способов назначения таймаутов.</p>
<pre><code>function foo(a, b, c) {}

// НИКОГДА не делайте такого
setTimeout(&#39;foo(1,2, 3)&#39;, 1000)

// Вместо этого используйте анонимную функцию
setTimeout(function() {
    foo(1, 2, 3);
}, 1000)</code></pre>
<aside>
<p><strong>Замечание:</strong> При том, что практически возможно использовать синтаксис <code>setTimeout(foo, 1000, 1, 2, 3)</code>, делать это крайне не рекомендуется — такие вызовы могут привести к трудно-отлавливаемым ошибкам при операциях с <a href="#function.this">методами</a>.</p>
</aside>
<h3 id="-">Заключение</h3>
<p><strong>Никогда</strong> не используйте строки как параметры для <code>setTimeout</code> или <code>setInterval</code>. Это явный признак <strong>действительно</strong> плохого кода. Если вызываемой функции необходимо передать аргументы, лучше передавать <em>анонимную функцию</em>, которая самостоятельно будет отвечать за сам вызов.</p>
<p>Кроме того, избегайте использования <code>setInterval</code>, поскольку его планировщик не блокируется выполняемым кодом.</p>
</div></article></section><section id="appendix"><!-- Introduction--><header id="appendix.intro"><h1>Пояснения</h1></header><!-- Articles--><article id="appendix.fromtranslators"><h2>От переводчиков</h2><div><p>Авторы этой документации требуют от читателя не совершать каких-либо ошибок и постоянно следить за качеством пишущегося кода. Мы, как переводчики и опытные программисты на JavaScript, рекомендуем <em>прислушиваться</em> к этим советам, но при этом не делать из этого <em>крайность</em>. Опыт — сын ошибок трудных, и иногда в борьбе с ошибками зарождается намного более детальное понимание предмета. Да, нужно избегать ошибок, но допускать их неосознанно — вполне нормально.</p>
<p>К примеру, в статье про <a href="#types.equality">сравнение объектов</a> авторы настоятельно рекомендуют использовать <em>только</em> оператор строгого неравенства <code>===</code>. Но мы считаем, что если вы уверены и осознали, что оба сравниваемых операнда имеют один тип, вы имеете право опустить последний символ <code>=</code>. Вы вольны применять строгое неравенство только в случаях, когда вы не уверены в типах операндов (<code>!== undefined</code> — это полезный приём). Так в вашем коде будут опасные и безопасные области, но при этом по коду будет явно видно, где вы рассчитываете на переменные одинаковых типов, а где позволяете пользователю вольности.</p>
<p>Функцию <a href="#other.timeouts"><code>setInterval</code></a> тоже можно использовать, если вы стопроцентно уверены, что код внутри неё будет исполняться как минимум в три раза быстрее переданного ей интервала.</p>
<p>С другой стороны, <a href="#function.scopes">использование <code>var</code></a> и грамотная <a href="#core.semicolon">расстановка точек с запятой</a> — обязательные вещи, халатное отношение к которым никак не может быть оправдано — в осознанном пропуске <code>var</code> (если только вы не переопределяете глобальный объект браузера... хотя <em>зачем</em>?) или точки с запятой нет никакого смысла.</p>
<p>Относитесь с <strong>мудростью</strong> к тому, что вы пишете — <em>важно</em> знать, как работает именно ваш код и как это соответствует приведённым в статье тезисам — и уже из этого вы сможете делать вывод, подходит ли вам тот или иной подход или нет. <em>Важно</em> знать, как работает <a href="#object.prototype">прототипное наследование</a>, но это не так необходимо, если вы используете функциональный подход или пользуетесь какой-либо сторонней библиотекой. Важно помнить о том, что у вас недостаёт какого-либо конкретного знания и что пробел следует заполнить, но если вы не используете в работе эту часть, вы всё равно можете писать хороший код — ну, если у вас есть талант.</p>
<p>Гонка за оптимизацией — это драматично и правильно, но лучше написать работающий и понятный вам код, а потом уже его оптимизировать и искать узкие места при необходимости. Оптимизацию необходимо делать, если вы видите явные неудобства для пользователя в тех или иных браузерах, или у вас один из тех супер-крупных проектов, которым никогда не помешает оптимизация, или вы работаете с какой-либо сверхтребовательной технологией типа WebGL. Данная документация очень поможет вам в определении этих узких мест.</p>
</div></article></section><!-- Footer--><footer><p>Copyright &copy;. Built with
|<a href="http://nodejs.org/">Node.js</a>using a<a href="https://github.com/visionmedia/jade/">jade</a>template.</p></footer><script src="//ajax.googleapis.com/ajax/libs/jquery/1.5.1/jquery.min.js"></script><script src="../javascript/prettify.js"></script><script src="../javascript/garden.js"></script></body></html>